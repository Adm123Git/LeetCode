# Лексикографически минимальная эквивалентная строка

https://leetcode.com/problems/lexicographically-smallest-equivalent-string/

### Сложность

Средняя

### Условие задачи

Даны две строки одинаковой длины s1 и s2.

Говорим, что s1[i] и s2[i] являются эквивалентными символами.

Например, если `s1 = "abc"` и `s2 = "cde"`, то мы имеем `'a' == 'c'`, `'b' == 'd'` и `'c' == 'e'`.

Эквивалентные символы следуют обычным правилам отношения эквивалентности:
```
Рефлексивность: 'a' == 'a'
Симметрия: 'a' == 'b' подразумевает 'b' == 'a'
Транзитивность: 'a' == 'b' и 'b' == 'c' подразумевает 'a' == 'c'
```
Например, учитывая информацию об эквивалентности из `s1 = "abc"` и `s2 = "cde"`, `acd` и `aab` являются строками, 
эквивалентными базовой `baseStr = "eed"`, при этом `"aab"` является лексикографически наименьшей из них.

### Примеры

---

Ввод:
```
baseStr = "parser"
s1 = "parker"
s2 = "morris"
```
Вывод:
```
"makkek"
```
Объяснение:
```
Используя информацию об эквивалентности s1 и s2, мы можем сгруппировать символы как [m,p], [a,o], [k,r,s], [e,i].
В каждой группе символы эквивалентны и отсортированы в лексикографическом порядке.
Таким образом ответ - "makkek".
```

---

Ввод:
```
baseStr = "hold"
s1 = "hello"
s2 = "world" 
```
Вывод:
```
"hdld"
```
Объяснение:
```
Используя информацию об эквивалентности s1 и s2, мы можем сгруппировать символы как [h,w], [d,e,o], [l,r].
Т.к. символ 'o' в baseStr заменяется на 'd', ответ - "hdld"
```

---

Ввод:
```
baseStr = "sourcecode"
s1 = "leetcode"
s2 = "programs"
```
Вывод:
```
"aauaaaaada"
```
Объяснение:
```
Используя информацию об эквивалентности s1 и s2, мы можем сгруппировать символы как [a,o,e,r,s,c], [l,p], [g,t], [d,m].
Тогда все сиволы baseStr, исключая 'u' и 'd' трансформируются в 'a' и ответ - "aauaaaaada".
```